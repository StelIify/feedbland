// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feeds.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFeeds = `-- name: CountFeeds :one
select count(*) from feeds
`

func (q *Queries) CountFeeds(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFeeds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFeed = `-- name: CreateFeed :one
insert into feeds (name, description, url, user_id, image_id)
values($1, $2, $3, $4, $5)
returning id, created_at, name, url, user_id
`

type CreateFeedParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         string      `json:"url"`
	UserID      int64       `json:"user_id"`
	ImageID     pgtype.Int8 `json:"image_id"`
}

type CreateFeedRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	UserID    int64     `json:"user_id"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (CreateFeedRow, error) {
	row := q.db.QueryRow(ctx, createFeed,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.UserID,
		arg.ImageID,
	)
	var i CreateFeedRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Url,
		&i.UserID,
	)
	return i, err
}

const generateNextFeedsToFetch = `-- name: GenerateNextFeedsToFetch :many
select id, name, url
from feeds
order by last_fetched_at asc nulls first
limit $1
`

type GenerateNextFeedsToFetchRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}

func (q *Queries) GenerateNextFeedsToFetch(ctx context.Context, limit int32) ([]GenerateNextFeedsToFetchRow, error) {
	rows, err := q.db.Query(ctx, generateNextFeedsToFetch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenerateNextFeedsToFetchRow
	for rows.Next() {
		var i GenerateNextFeedsToFetchRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
select f.id, f.created_at, f.name, f.url, f.user_id, f.description,
coalesce(images.url, 'https://feebland.s3.eu-west-3.amazonaws.com/feedsImg/default-feed-image.jpg') as image_url, coalesce(images.name, 'default image') as image_alt
from feeds f
left join images on images.id=f.image_id
where (to_tsvector('simple', f.name) @@ plainto_tsquery('simple', $1) or $1 = '')
order by created_at desc
limit $2 offset $3
`

type ListFeedsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type ListFeedsRow struct {
	ID          int64       `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	Name        string      `json:"name"`
	Url         string      `json:"url"`
	UserID      int64       `json:"user_id"`
	Description pgtype.Text `json:"description"`
	ImageUrl    string      `json:"image_url"`
	ImageAlt    string      `json:"image_alt"`
}

func (q *Queries) ListFeeds(ctx context.Context, arg ListFeedsParams) ([]ListFeedsRow, error) {
	rows, err := q.db.Query(ctx, listFeeds, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsRow
	for rows.Next() {
		var i ListFeedsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Url,
			&i.UserID,
			&i.Description,
			&i.ImageUrl,
			&i.ImageAlt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedFetched = `-- name: MarkFeedFetched :exec
update feeds
set last_fetched_at=now(), updated_at=now()
where id=$1
`

func (q *Queries) MarkFeedFetched(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markFeedFetched, id)
	return err
}
