// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feeds.sql

package database

import (
	"context"
	"time"
)

const createFeed = `-- name: CreateFeed :one
insert into feeds (name, description, url, user_id, image_id)
values($1, $2, $3, $4, $5)
returning id, created_at, name, url, user_id
`

type CreateFeedParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Url         string `json:"url"`
	UserID      int64  `json:"user_id"`
	ImageID     int64  `json:"image_id"`
}

type CreateFeedRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	UserID    int64     `json:"user_id"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (CreateFeedRow, error) {
	row := q.db.QueryRow(ctx, createFeed,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.UserID,
		arg.ImageID,
	)
	var i CreateFeedRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Url,
		&i.UserID,
	)
	return i, err
}

const generateNextFeedsToFetch = `-- name: GenerateNextFeedsToFetch :many
select id, name, url from feeds
order by last_fetched_at asc nulls first
limit $1
`

type GenerateNextFeedsToFetchRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}

func (q *Queries) GenerateNextFeedsToFetch(ctx context.Context, limit int32) ([]GenerateNextFeedsToFetchRow, error) {
	rows, err := q.db.Query(ctx, generateNextFeedsToFetch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenerateNextFeedsToFetchRow
	for rows.Next() {
		var i GenerateNextFeedsToFetchRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
select f.id, f.created_at, f.name, f.url, f.user_id, images.url as image_url, images.name as image_alt from feeds f
join images on images.id=f.image_id
order by created_at
`

type ListFeedsRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	UserID    int64     `json:"user_id"`
	ImageUrl  string    `json:"image_url"`
	ImageAlt  string    `json:"image_alt"`
}

func (q *Queries) ListFeeds(ctx context.Context) ([]ListFeedsRow, error) {
	rows, err := q.db.Query(ctx, listFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsRow
	for rows.Next() {
		var i ListFeedsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Url,
			&i.UserID,
			&i.ImageUrl,
			&i.ImageAlt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedFetched = `-- name: MarkFeedFetched :exec
update feeds
set last_fetched_at=now(), updated_at=now()
where id=$1
`

func (q *Queries) MarkFeedFetched(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markFeedFetched, id)
	return err
}
